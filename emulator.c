// flag{s0_s3cr3t_y3t_s0_fr33}
#include <stdio.h>
#include <stdlib.h>

#define N_TRACE

// checks if a valid register is accessed (by testing if op < 8)
// exits if op >= 8 as it makes the instruction illegal
void check_index(unsigned char op)
{
	if (op >= 8) {
		printf("Illegal instruction - invalid register %i\n", op);
		exit(-1);
	}
}

unsigned char memory[256] = {
	0x00,0x00,0x80,0x00,0x01,0x00,0x00,0x02,0x1C,0x03,0x00,0x01,0x08,0x03,0x00,0x02,
	0x03,0x07,0x05,0x03,0x00,0x04,0x00,0x01,0x01,0x01,0x01,0x02,0x02,0x01,0x06,0x02,
	0x09,0xff,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
	0x6d,0x73,0x68,0x6e,0x82,0x7a,0x37,0x66,0x7a,0x3a,0x6a,0x79,0x3a,0x7b,0x66,0x80,
	0x3a,0x7b,0x66,0x7a,0x37,0x66,0x6d,0x79,0x3a,0x3a,0x84,0x11,0x00,0x00,0x00,0x00,
	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00
};

unsigned char registers[8] = { 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 };

void print_registers()
{
#ifndef N_TRACE
	for (int i = 0; i < 8; i++) {
		printf("%i ", registers[i]);
	}
	printf("\n");
#endif
}

void print_instruction(unsigned char op0, unsigned char op1, unsigned char op2)
{
#ifndef N_TRACE
	char opcode_names[11][5] = {"LODC", "ADDC", "SUBC", "ADDR", "SUBR", "PRNT", "JMNZ", "JMIZ", "LODM", "STRM", "HALT"};
	printf("%s %i %i\n", opcode_names[op0], op1, op2);
#endif
}
int main ()
{
	int instruction_pointer = 0;

	char output_buf[1024] = "";
	int output_buf_pointer = 0;

	print_registers();
	print_instruction(memory[0], memory[1], memory[2]);

	while(1) {
		unsigned char op0 = memory[instruction_pointer+0];
		unsigned char op1 = memory[instruction_pointer+1];
		unsigned char op2 = memory[instruction_pointer+2];
		
		instruction_pointer += 3;

		switch(op0) {
			case 0x00:
				// LOAD_CONST
				check_index(op1);
				registers[op1] = op2;
				break;
			case 0x01:
				// ADD_CONST
				check_index(op1);
				registers[op1] += op2;
				break;
			case 0x02:
				// SUB_CONST
				check_index(op1);
				registers[op1] -= op2;
				break;
			case 0x03:
				// ADD
				check_index(op1);
				check_index(op2);
				registers[op1] += registers[op2];
				break;
			case 0x04:
				// SUB
				check_index(op1);
				check_index(op2);
				registers[op1] -= registers[op2];
				break;
			case 0x05:
				// PRINT
				check_index(op1);
				output_buf[output_buf_pointer] = registers[op1];
				output_buf_pointer += 1;
				break;
			case 0x06:
				// JUMP_IF_NOT_ZERO
				check_index(op1);
				if (registers[op1] != 0) {
					instruction_pointer = op2;
				}
				break;
			case 0x07:
				// JUMP_IF_ZERO
				check_index(op1);
				if (registers[op1] == 0) {
					instruction_pointer = op2;
				}
				break;
			case 0x08:
				// LOAD
				check_index(op1);
				check_index(op2);
				registers[op1] = memory[registers[op2]];
				break;
			case 0x09:
				// STORE
				check_index(op1);
				check_index(op2);
				memory[registers[op1]] = registers[op2];
				break;
			case 0xff:
				// HALT
				print_registers();
				printf("%s", output_buf);
				return 0;
			default:
				printf("Illegal instruction - invalid opcode %i\n", op0);
				return -1;
		}
		
		print_registers();
		print_instruction(op0, op1, op2);
	}

	return 0;
}
